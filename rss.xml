<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Sirens007</title><description>Blog</description><link>https://sirens007.github.io/</link><language>zh_CN</language><item><title>Java 类与对象</title><link>https://sirens007.github.io/posts/class-and-object/</link><guid isPermaLink="true">https://sirens007.github.io/posts/class-and-object/</guid><description>深度学习Java的类与对象.</description><pubDate>Mon, 22 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1.定义类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/java-object.ChjM1FGS_wOiaq.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Dog {
    String breed;
    int size;
    String colour;
    int age;
 
    void eat() {
    }
 
    void run() {
    }
 
    void sleep(){
    }
 
    void name(){
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt;：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成员变量&lt;/strong&gt;：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类变量&lt;/strong&gt;：类变量也声明在类中，方法体之外，但必须声明为 static 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.一般一个文件当中只定义一个类&lt;/p&gt;
&lt;p&gt;2.main方法所在的类一般要使用public修饰&lt;/p&gt;
&lt;p&gt;3.public修饰的类必须要与文件名相同&lt;/p&gt;
&lt;p&gt;4.不要随意修改public修饰的类的名字&lt;/p&gt;
&lt;h2&gt;2.创建对象（类的实例化）&lt;/h2&gt;
&lt;p&gt;对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;声明&lt;/strong&gt;：声明一个对象，包括对象名称和对象类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例化&lt;/strong&gt;：使用关键字 new 来创建一个对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：使用 new 创建对象时，会调用构造方法初始化对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个创建对象的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Puppy{
   public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println(&quot;小狗的名字是 : &quot; + name ); 
   }
   public static void main(String[] args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( &quot;Sirens&quot; );
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出内容为以下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;小狗的名字是：Sirens&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;3.访问实例（成员）变量与方法&lt;/h2&gt;
&lt;p&gt;通过已创建的对象来访问成员方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 实例化对象 */
Object referenceVariable = new Constructor();
/* 访问类中的变量 */
referenceVariable.variableName;
/* 访问类中的方法 */
referenceVariable.methodName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实质上在main方法中通过&lt;code&gt;.&lt;/code&gt;来访问对象中的变量以及方法&lt;/p&gt;
&lt;h2&gt;4.构造方法&lt;/h2&gt;
&lt;p&gt;每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。&lt;/p&gt;
&lt;p&gt;在创建一个对象的时候，至少要调用一个构造方法。&lt;strong&gt;构造方法的名称必须与类同名&lt;/strong&gt;，一个类可以有多个构造方法。&lt;/p&gt;
&lt;p&gt;下面是一个构造方法示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Puppy{
    public Puppy(){
    }
 
    public Puppy(String name){
        // 这个构造器仅有一个参数：name
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;注意： &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;this(...)必须是构造方法中第一条语句&amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;5.综上范例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public class Employee{
	private String name;
	private int age;
	private String designation;//称号
	private double salary;
	
	public Employee(String name,int age){
		this.name = name;
		this.age = age;
	}
	
	public void setAge(int age){
		this.age = age;
	}
	
	public int getAge(){
		return age;
	}
	
	public void setDesignation(String designation){
		this.designation = designation;
	}

	public String getDesignation(){
		return designation;
	}
	
	public void setSalary(double salary){
		this.salary = salary;
	}
		
	public double getSalary(){
			return salary;
		}

	// 打印信息
	public void printEmployee() {
		System.out.println(this);
	}

	// 重写 toString 方法
	@Override
	public String toString() {
		return &quot;名字: &quot; + name + &quot;\n&quot; +
				&quot;年龄: &quot; + age + &quot;\n&quot; +
				&quot;职位: &quot; + designation + &quot;\n&quot; +
				&quot;薪水: &quot; + salary;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;this引用指向当前对象(成员方法运行时调用该成员方法的对象)，在成员方法中所有成员变量的操作，都是通过该 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;引用去访问&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在类中访问类的变量时，尽量&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;养成使用&amp;lt;/font&amp;gt;&lt;code&gt;this&lt;/code&gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;的习惯&amp;lt;/font&amp;gt;，防止出现形参赋值给形参的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;默认初始化&lt;/h3&gt;
&lt;p&gt;对象空间被申请好之后，对象中包含的成员已经设置好了初始值，比如&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;&apos;\u0000&apos;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;0L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;0.0f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reference&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;6.源文件声明规则&lt;/h2&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;一个源文件中只能有一个 public 类&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;一个源文件可以有多个非 public 类&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7.封装&lt;/h2&gt;
&lt;p&gt;封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。&lt;/p&gt;
&lt;p&gt;要访问该类的代码和数据，必须通过严格的接口控制。&lt;/p&gt;
&lt;p&gt;封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。&lt;/p&gt;
&lt;p&gt;适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。&lt;/p&gt;
&lt;h3&gt;7.1访问限定符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;private&lt;/th&gt;
&lt;th&gt;default&lt;/th&gt;
&lt;th&gt;protected&lt;/th&gt;
&lt;th&gt;public&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同一包中的同一类&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同一包中的不同类&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不同包中的子类&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不同包中的非子类&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;public：可以理解为一个人的外貌特征，谁都可以看得到 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;default: &amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;对于自己家族中&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;(&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;同一个包中&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;)&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;不是什么秘密，对于其他人来说就是隐私了 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;private：只有自己知道，其他人都不知道&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;【&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;说明&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;】 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;protected&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;主要是用在继承中，继承部分详细介绍 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;default&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;权限指：什么都不写时的默认权限 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;访问权限除了可以限定类中成员的可见性，也可以控制类的可见性&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h3&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;7.2实现Java封装的步骤&amp;lt;/font&amp;gt;&lt;/h3&gt;
&lt;p&gt;1.修改属性的可见性来限制对属性的访问（一般限制为private），例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Person {
    private String name;
    private int age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;这段代码中，将 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;name&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 和 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;age&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;2.对每个值属性提供对外的公共方法访问，也就是创建一对赋取值的方法，用于对私有属性的访问，例如：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Person{
    private String name;
    private int age;
​
    public int getAge(){
      return age;
    }
​
    public String getName(){
      return name;
    }
​
    public void setAge(int age){
      this.age = age;
    }
​
    public void setName(String name){
      this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;采用 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;this&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;以上实例中public方法是外部类访问该类成员变量的入口。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;通常情况下，这些方法被称为getter和setter方法。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;因此，任何要访问类中私有成员变量的类都要通过这些&lt;strong&gt;getter&lt;/strong&gt;和&lt;strong&gt;setter&lt;/strong&gt;方法。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h2&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;8.Java包（Package）&amp;lt;/font&amp;gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;包的作用&amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;包语句的语法格式为：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package pkg1[．pkg2[．pkg3…]];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;8.1 创建包&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;基本规则 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;在文件的最上方加上一个&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt; package &amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;语句指定该代码在哪个包中&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;. &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;包名需要尽量指定成唯一的名字, 通常会用公司的域名的颠倒形式(例如 io.github.sirens007 )&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;包名要和代码路径相匹配. 例如创建&amp;lt;/font&amp;gt;&lt;code&gt;io.github.sirens007&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;的包, 那么会存在一个对应的路径 &amp;lt;/font&amp;gt;&lt;code&gt;io.github.sirens007&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;来存储代码.&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;如果一个类没有 package 语句, 则该类被放到一个默认包中.&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/java-image.CU2iMGJq_1Agdzg.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;即图中&lt;code&gt;软件包&lt;/code&gt;，点击后输入&lt;code&gt; io.github.sirens007&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;则会创建一个三级目录&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h3&gt;8.2 import 关键字&lt;/h3&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;在 Java 中，&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;import&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; &amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;关键字用于导入其他类或包中定义的类型，以便在当前源文件中使用这些类型。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;import&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; &amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;关键字用于引入其他包中的类、接口或静态成员，它允许你在代码中直接使用其他包中的类，而不需要完整地指定类的包名。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;在 java 源文件中 import 语句必须位于 Java 源文件的头部，其语法格式为：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import package1[.package2…].(classname|*);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 语句位于 &lt;code&gt;package&lt;/code&gt; 语句之后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 第一行非注释行是 package 语句
package com.example;
 
// import 语句引入其他包中的类
import java.util.ArrayList;
import java.util.List;
 
// 类的定义
public class MyClass {
    // 类的成员和方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);&quot;&amp;gt;如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);&quot;&amp;gt;可以使用 import语句来引入一个特定的类：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import  io.github.sirens007;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;这样，你就可以在当前源文件中直接使用 sirens007 类的方法、变量或常量。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;也可以使用通配符 &amp;lt;/font&amp;gt;&lt;code&gt;*&lt;/code&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 来引入整个包或包的子包：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import io.sirens007.mypackage.*;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;这样，你可以导入 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;io.sirens007.mypackage&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 包中的所有类，从而在当前源文件中使用该包中的任何类的方法、变量或常量。注意，使用通配符 &amp;lt;/font&amp;gt;&lt;code&gt;*&lt;/code&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 导入整个包时，只会导入包中的类，而&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;不会导入包中的&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;子包&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;在导入类或包时，你需要提供&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;类的完全限定名或包的完全限定名&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;。完全限定名包括包名和类名的组合，以点号 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;.&amp;lt;/font&amp;gt;&lt;/strong&gt; 分隔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList; // 引入 java.util 包中的 ArrayList 类
import java.util.*; // 引入 java.util 包中的所有类

import com.example.MyClass; // 引入 com.example 包中的 MyClass 类
import com.example.*; // 引入 com.example 包中的所有类
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;8.2.1 常见的包&lt;/h4&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;1. java.lang:系统常用基础类(String、Object),此包从JDK1.1后自动导入。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;2. java.lang.reflect:java &amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;反射编程包&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;; &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;3. java.net:&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;进行网络编程开发包。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;4. java.sql:&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;进行数据库开发的支持包。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;5. java.util:&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;是&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;java&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;提供的工具程序包。&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;(&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;集合类等&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;) &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;非常重要 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;6. java.io:I/O编程开发包。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h3&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;8.3 Package 的目录结构&amp;lt;/font&amp;gt;&lt;/h3&gt;
&lt;p&gt;类放在包中会有两种主要的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包名成为类名的一部分，正如我们前面讨论的一样。&lt;/li&gt;
&lt;li&gt;包名必须与相应的字节码所在的目录结构相吻合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是管理你自己 java 中文件的一种简单方式：&lt;/p&gt;
&lt;p&gt;将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 文件名 :  Car.java
package vehicle;
 
public class Car {
   // 类实现  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(250, 252, 253);&quot;&amp;gt;接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;....\vehicle\Car.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，正确的类名和路径将会是如下样子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类名 -&amp;gt; vehicle.Car&lt;/li&gt;
&lt;li&gt;路径名 -&amp;gt; vehicle\Car.java (在 windows 系统中)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;例如：有一个 &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;io.github.test&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; 的包，这个包包含一个叫做 Hello.java 的源文件，那么相应的，应该有如下面的一连串子目录：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;....\io\github\test\Hello.java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 文件名: Hello.java
 
package io.github.test;
public class Hello {
      
}
class Google {
      
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;现在，我们用-d选项来编译这个文件，如下：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;$javac -d . Hello.java&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;这样会像下面这样放置编译了的文件：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\io\github\test\Hello.class
.\io\github\test\Google.class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;你可以像下面这样来导入所有&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt; \io\github\test\ &amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;中定义的类、接口等：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;import io.github.test.*;&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;path-one&amp;gt;\sources\io\github\test\Hello.java
&amp;lt;path-two&amp;gt;\classes\io\github\test\Google.class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#262626;&quot;&amp;gt;这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;h2&gt;9.static 成员&lt;/h2&gt;
&lt;h3&gt;9.1static 修饰成员变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;static修饰的成员变量，称为静态成员变量&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，静态成员变量最大的特性：&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;不属于某个具体的对象，是所有对象所共享的&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。&lt;/p&gt;
&lt;p&gt;重点：类的静态成员变量特性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.不属于某个具体的对象，是类的属性，所有对象共享的，不存储在某个对象的空间中&lt;/p&gt;
&lt;p&gt;2.既可以通过对象访问，也可以通过类名访问，但一般更推荐使用类名访问&lt;/p&gt;
&lt;p&gt;3.静态类变量存储在方法区中&lt;/p&gt;
&lt;p&gt;4.&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;生命周期伴随类的一生(即：随类的加载而创建，随类的卸载而销毁)&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;类的加载和卸载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载（Load）&lt;/strong&gt;：当你第一次使用这个类（比如 &lt;code&gt;new&lt;/code&gt;、访问静态变量/方法）时，JVM 的类加载器会把它加载到 &lt;strong&gt;方法区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卸载（Unload）&lt;/strong&gt;：当一个类不再被任何地方使用时，JVM 才有可能把它卸载。&lt;/p&gt;
&lt;h3&gt;9.2static 修饰成员方法&lt;/h3&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;Java中，&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;被static修饰的成员方法称为静态成员方法，是类的方法，不是某个对象所特有的&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。静态成员一般是通过静态方法来访问的。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;重点：静态方法特性&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;1.不属于某个具体的对象，是类方法&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;2.可以通过对象调用，也可以通过 &amp;lt;/font&amp;gt;&lt;code&gt;类名.静态方法名(...)&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;方式调用，更推荐类名调用&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;3.不能在静态方法中访问任何非静态成员变量&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;4. 静态方法中不能调用任何非静态方法，因为非静态方法有this参数，在静态方法中调用时候无法传递this引用&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;5. 静态方法无法重写，不能用来实现多态(此处大家暂时不用管，后序多态位置详细讲解)。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;补充第三点：&amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态变量/方法（static）&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;属于 &amp;lt;/font&amp;gt;&lt;strong&gt;类本身&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，不依赖某个对象，类一加载就存在。&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;调用方式：&amp;lt;/font&amp;gt;&lt;code&gt;类名.方法()&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt; 或者 &amp;lt;/font&amp;gt;&lt;code&gt;对象.方法()&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;（其实推荐用类名）。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非静态变量/方法（实例成员）&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;属于 &amp;lt;/font&amp;gt;&lt;strong&gt;对象实例&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，必须通过 &amp;lt;/font&amp;gt;&lt;code&gt;new&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt; 出来的对象才会存在。&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;调用方式：&amp;lt;/font&amp;gt;&lt;code&gt;对象.方法()&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**Q1:为什么静态方法不能访问非静态变量呢 **&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;因为静态方法执行的时候，对象可能还没有创建&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;eg:&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Demo {
    int age = 10;         // 非静态变量（实例变量）
    static int count = 0; // 静态变量

    static void printInfo() {
        System.out.println(age); // ❌ 报错！
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JVM 加载 &lt;code&gt;Demo&lt;/code&gt; 类时，&lt;code&gt;count&lt;/code&gt; 已经存在（方法区 / 元空间里）。&lt;/li&gt;
&lt;li&gt;但是 &lt;code&gt;age&lt;/code&gt; 是实例变量，只有在执行 &lt;code&gt;new Demo()&lt;/code&gt; 时，才会分配内存到堆里。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static void printInfo()&lt;/code&gt; 可能在没有任何对象的时候被调用，这时 JVM 不知道该取哪个对象的 &lt;code&gt;age&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以编译器直接禁止你在静态方法里访问 &lt;code&gt;age&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2:&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;. 静态方法中为什么不能调用任何非静态方法？&amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;我们先复习一下静态和非静态方法&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态方法&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;属于类本身，类加载时就存在，不依赖对象。调用时 JVM 直接用「类信息」执行，不需要 new 对象。  &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非静态方法&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;属于对象实例，必须依赖对象才能调用。JVM 在调用时，默认会传入一个隐藏的 &amp;lt;/font&amp;gt;&lt;code&gt;this&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt; 指针，告诉方法「我是谁」，这样方法才能访问对象里的实例变量。  &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;他们的关键区别在于是否有&amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;调用非静态方法时，编译器会在字节码层面自动加上 &amp;lt;/font&amp;gt;&lt;code&gt;this&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。&lt;br /&gt;
&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;比如写：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.sayHello();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;编译后相当于：&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Demo.sayHello(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;调用静态方法时，不存在 &amp;lt;/font&amp;gt;&lt;code&gt;this&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，因为它不依赖对象。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Demo.staticHello();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;编译后就是单纯的 &amp;lt;/font&amp;gt;&lt;code&gt;Demo.staticHello()&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，没有对象上下文&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;因此静态方法里没有&amp;lt;/font&amp;gt;&lt;code&gt;this&lt;/code&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;，所以编译器根本不知道你想让哪个对象去执行这个非静态方法。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;方法一：在静态方法里创建对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void test() {
    Demo d = new Demo();
    d.sayHello(); // ✅ 通过对象调用非静态方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二：把目标方法也改成静态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void sayHello() {
    System.out.println(&quot;Hello from static method&quot;);
}

static void test() {
    sayHello(); // ✅ 直接调用
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结就是： **静态方法不能调用非静态方法，是因为静态方法没有 &lt;code&gt;this&lt;/code&gt;，而非静态方法必须依赖 &lt;code&gt;this&lt;/code&gt; 才能运行 **&lt;/p&gt;
&lt;h3&gt;9.3static 成员变量初始化&lt;/h3&gt;
&lt;p&gt;初始化方法有以下：&lt;/p&gt;
&lt;p&gt;1.就地初始化&lt;/p&gt;
&lt;p&gt;2.通过get、set方法初始化&lt;/p&gt;
&lt;p&gt;3.构造方法初始化（相对较少）&lt;/p&gt;
&lt;p&gt;4.代码块初始化&lt;/p&gt;
&lt;h2&gt;10.代码块&lt;/h2&gt;
&lt;h3&gt;10.1 代码块分类&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;{}&lt;/code&gt;定义的一段代码称为代码块，根据代码块定义的位置以及关键字，又可分为以下四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态代码块（&lt;strong&gt;一般用于初始化静态成员变量）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;非静态代码块/实例代码块/构造代码块&lt;/li&gt;
&lt;li&gt;同步代码块...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;代码块执行顺序&lt;/h3&gt;
&lt;p&gt;静态代码块 -&amp;gt; 实例代码块 -&amp;gt; 构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;注意：&amp;lt;/font&amp;gt;&lt;/strong&gt; &lt;strong&gt;静态代码块只会执行一次（涉及知识点：双亲委派模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;补充：如果静态/实例代码块有平级，那么就和他们各自类型的先后顺序有关系&lt;/p&gt;
&lt;p&gt;构造方法主要看调用了的哪个构造&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;注意事项 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态代码块不管生成多少个对象，其只会执行一次 &amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态成员变量是类的属性，因此是在&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;JVM&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;加载类时开辟空间并初始化的 &amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;如果一个类中包含多个静态代码块，在编译代码时，编译器会按照定义的先后次序依次执行&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;(&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;合并&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;) &amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;实例代码块只有在创建对象时才会执行&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class Main{
    String number = &quot;123&quot;;
    {
        number = &quot;125&quot;;
        System.out.println(&quot;eg coder&quot;);
    }

    Main(String number){
        this.number = number;
        System.out.println(&quot;struction func&quot;);
    }

    static{
        String number = &quot;124&quot;;
        System.out.println(&quot;static coder&quot;);
    }
}


//输出结果：
//static coder
//eg coder
//struction func
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对象的打印&lt;/h2&gt;
&lt;p&gt;平常我们直接打印对象时，会直接输出&lt;code&gt;对象名+ @ +一串字符&lt;/code&gt; 这实际上是toString默认方法&lt;/p&gt;
&lt;p&gt;如图下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/java-image2.BRVsI_bd_1thlSM.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但当我们自己写上了toString方法的时候，就会输出我们自己想要的内容了&lt;/p&gt;
&lt;p&gt;快捷键：&lt;code&gt;Alt+Insert&lt;/code&gt;选中toString即可（静态方法默认不输出，需要可自己补充）&lt;/p&gt;
</content:encoded></item><item><title>Java语言基础知识2</title><link>https://sirens007.github.io/posts/javase2/</link><guid isPermaLink="true">https://sirens007.github.io/posts/javase2/</guid><description>初步学习Java语法.</description><pubDate>Tue, 16 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第四节.运算符&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.仅补充%&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(10%3);//1
System.out.println(-10%3);//-1
System.out.println(10%-3);//1
System.out.println(-10%-3);//-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.前置++与后置++&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以理解为+号在前面就先加，加号在后面就不加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;int a = 1;
int b = ++a;
int c = a++;

System.out.println(b);	//2
System.out.println(c);	//1

//但要注意
a=a++;	//1,与c++不同
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.关系运算符&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;lt; , &amp;gt; , &amp;lt;= , &amp;gt;= ,==  返回值：true or false;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;4.逻辑运算符&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑与（都为真才真）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true &amp;amp;&amp;amp; false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;`&lt;/td&gt;
&lt;td&gt;逻辑或（有一个真就真）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑非（取反）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;逻辑与&lt;/p&gt;
&lt;p&gt;1.两个表达式必须都是布尔表达式&lt;/p&gt;
&lt;p&gt;2.如果第一个表达式为假，那么就不会执行第二个表达式&lt;/p&gt;
&lt;p&gt;逻辑或&lt;/p&gt;
&lt;p&gt;1.两个表达式必须都是布尔表达式&lt;/p&gt;
&lt;p&gt;2.只要有一个为真，那么整体为真&lt;/p&gt;
&lt;p&gt;3.假设第一个为真，那么第二个就不会执行&lt;/p&gt;
&lt;p&gt;逻辑非&lt;/p&gt;
&lt;p&gt;1.作用在布尔表达式&lt;/p&gt;
&lt;p&gt;&amp;amp; 和 | 如果表达式结果为 boolean 时，也表示逻辑运算，但与 &amp;amp;&amp;amp; || 相比，他们不支持短路求值，&lt;/p&gt;
&lt;p&gt;如果两边不是布尔表达式，那么还是按位与 按位或操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(10 &amp;gt; 20 &amp;amp; 10 / 0 ==0)l;		//程序输出异常
System.out.println(10 &amp;lt; 20 | 10 / 0 ==0)l;		//程序输出异常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他们逻辑符号两侧都会执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.位运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按位与&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00001010
00010100
---------
00000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按位或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00001010
00010100
---------
00011110
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按位异或：如果该位为 0 则转为 1，如果该位为 1 则转为 0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.左移1位，相当于原数字 *2，左移N位，相当于原数字 *2 的N次方.&lt;/p&gt;
&lt;p&gt;2.右移1位，相当于原数字 /2，右移N位，相当于原数字 /2 的N次方.&lt;/p&gt;
&lt;p&gt;3.偶遇计算机计算位移效率高于计算乘除，当某个代码正好乘除 2 的N次方的时候可以用位移运算代替.&lt;/p&gt;
&lt;p&gt;4.移动负数位或者移位位数过大都没有意义.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第五节.循环语句&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;适合：已知次数的循环&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= 5; i++) {
    System.out.println(&quot;第 &quot; + i + &quot; 次执行&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：打印 1 到 5。&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; 循环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;适合：不知道循环次数，但有一个条件控制&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
while (i &amp;lt;= 5) {
    System.out.println(&quot;第 &quot; + i + &quot; 次执行&quot;);
    i++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和上面的效果一样。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;do...while&lt;/code&gt; 循环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;至少执行一次&lt;/strong&gt;，再判断条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
do {
    System.out.println(&quot;第 &quot; + i + &quot; 次执行&quot;);
    i++;
} while (i &amp;lt;= 5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 &lt;code&gt;while&lt;/code&gt; 的区别是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- `while`：先判断，再执行。
- `do...while`：先执行，再判断。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;switch&lt;/code&gt;语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;适合选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch(表达式){
    case 常量值1:{
        语句1;
        [break;]
    }
    case 常量值2:{
        语句2;
        [break;]
    }
    ...
    default:{
        内容都不满足时执行语句;
        [break;]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;多个&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;case&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;后的常量值不可以重复 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;switch&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;的括号内只能是以下类型的表达式： &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;基本类型：byte、char、short、int，注意不能是long类型 &amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;引用类型：String常量串、枚举类型&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六节.数组（Array）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;什么是数组？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数组就是 &lt;strong&gt;一组相同类型的数据&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;它可以用一个名字存放多个数据，并通过 &lt;strong&gt;下标（索引）&lt;/strong&gt; 来访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] scores = {95, 88, 76, 100};
System.out.println(scores[0]); // 输出第一个元素 95
System.out.println(scores[3]); // 输出第四个元素 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👉 注意：数组的下标是 &lt;strong&gt;从 0 开始&lt;/strong&gt; 的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组的声明与初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;数组的初始化主要分为&amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;动态初始化以及静态初始化&amp;lt;/font&amp;gt;&lt;/strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;1. &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;动态初始化：在创建数组时，直接指定数组中元素的个数 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] array = new int[10];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;2. &amp;lt;/font&amp;gt;&lt;strong&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态初始化：在创建数组时不直接指定数据元素个数，而直接将具体的数据内容进行指定 &amp;lt;/font&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;语法格式： T[] 数组名称 = {data1, data2, data3, ..., datan};&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] array1 = new int[]{0,1,2,3,4,5,6,7,8,9};
double[] array2 = new double[]{1.0, 2.0, 3.0, 4.0, 5.0};
String[] array3 = new String[]{&quot;hell&quot;, &quot;Java&quot;, &quot;!!!&quot;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;【注意事项】 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态初始化虽然没有指定数组的长度，编译器在编译时会根据&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;{}&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;中元素个数来确定数组的长度。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态初始化时&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;, {}&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;中数据类型必须与&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;[]&amp;lt;/font&amp;gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;前数据类型一致。 &amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;静态初始化可以简写，省去后面的new T[]。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51,51,51);&quot;&amp;gt;3.数组初始化内容&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;0.0f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;/u0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;遍历数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用循环来访问数组的所有元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] arr = {10, 20, 30, 40, 50};
for (int i = 0; i &amp;lt; arr.length; i++) {
    System.out.println(&quot;第 &quot; + (i+1) + &quot; 个元素：&quot; + arr[i]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里 &lt;code&gt;arr.length&lt;/code&gt; 表示数组的长度。&lt;/p&gt;
&lt;p&gt;5.二维数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;数据类型[][] 数组名称 = new 数据类型 [行数][列数];
数据类型[][] 数组名称 = new 数据类型 [][] { 初始化数据 };
数据类型[][] 数组名称 = new 数据类型 [行数][];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充对二维数组是一维数组的深度理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[][] array ={{1,2,3},{4,5,6}};
System.out.println(array.length); //2
System.out.println(array[0].length);//3
System.out.println(Arrays.toString(array[1])); //[4, 5, 6]
String ret = System.out.println(Arrays.deepToString(array));
System.out.println(ret);	//[[1,2,3],[4,5,6]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中array的底层为图中所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/image.CBPApiEO_Z1BCPfK.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;数组补充内容&lt;/h3&gt;
&lt;h4&gt;1. 找最大值和最小值&lt;/h4&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设第一个元素是最大/最小值。&lt;/li&gt;
&lt;li&gt;遍历数组，依次比较更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int[] arr = {12, 45, 7, 89, 23};
int max = arr[0];
int min = arr[0];

for (int i = 1; i &amp;lt; arr.length; i++) {
    if (arr[i] &amp;gt; max) {
        max = arr[i];
    }
    if (arr[i] &amp;lt; min) {
        min = arr[i];
    }
}
System.out.println(&quot;最大值：&quot; + max);
System.out.println(&quot;最小值：&quot; + min);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 倒序输出数组&lt;/h4&gt;
&lt;p&gt;有时我们希望反过来输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] arr = {1, 2, 3, 4, 5};
for (int i = arr.length - 1; i &amp;gt;= 0; i--) {
    System.out.print(arr[i] + &quot; &quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👉 这个思路也能用于「数组反转」。&lt;/p&gt;
&lt;h4&gt;3. for each遍历（增强 for 循环）&lt;/h4&gt;
&lt;p&gt;Java 提供了简化的遍历写法（但不能改变数组里的值）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] arr = {10, 20, 30};
for (int num : arr) {
    System.out.println(num);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4. 多维数组（二维数组）&lt;/h4&gt;
&lt;p&gt;二维数组 = 表格。&lt;br /&gt;
比如存放学生成绩（3 个学生，每人 2 门课）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[][] scores = {
    {90, 85},
    {70, 88},
    {100, 95}
};
System.out.println(scores[0][1]); // 第1个学生的第2门课成绩 85
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Java语言基础知识</title><link>https://sirens007.github.io/posts/javase/</link><guid isPermaLink="true">https://sirens007.github.io/posts/javase/</guid><description>初步学习Java语法.</description><pubDate>Wed, 03 Sep 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第一节.标识符&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;即：在程序中由用户给类名、方法名或者变量所取的名字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效字符：数字、字母、下划线、美元符号&lt;/p&gt;
&lt;p&gt;其中&amp;lt;span style=&quot;color:red&quot;&amp;gt;&lt;strong&gt;不能以数字开头，不能是关键字除（main），可以以下划线、美元符号开头&lt;/strong&gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
    //psvm
    public static void main(String[] args) {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.java的数组的定义方式：int[] array&lt;/p&gt;
&lt;p&gt;C语言数组的定义方式：int arr[] 其中int[]才为类型 ，因此java是修正过来了&lt;/p&gt;
&lt;p&gt;2.在java当中，函数叫做方法。&lt;/p&gt;
&lt;h2&gt;第二节.关键字&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用于定义访问权限修饰符的关键字&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;protected&lt;/td&gt;
&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于定义类，函数，变量修饰符的关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;abstract&lt;/td&gt;
&lt;td&gt;final&lt;/td&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于定义类与类之间关系的关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;extends&lt;/td&gt;
&lt;td&gt;implements&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于定义建立实例及引用实例，判断实例的关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;new&lt;/td&gt;
&lt;td&gt;this&lt;/td&gt;
&lt;td&gt;super&lt;/td&gt;
&lt;td&gt;instanceof&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于异常处理的关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;try&lt;/td&gt;
&lt;td&gt;catch&lt;/td&gt;
&lt;td&gt;finally&lt;/td&gt;
&lt;td&gt;throw&lt;/td&gt;
&lt;td&gt;throws&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用于包的关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;import&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他修饰符关键字&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;native&lt;/td&gt;
&lt;td&gt;strictfp&lt;/td&gt;
&lt;td&gt;transient&lt;/td&gt;
&lt;td&gt;volatile&lt;/td&gt;
&lt;td&gt;assert&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;第三节.数据类型与变量&lt;/h2&gt;
&lt;h3&gt;数据类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/JavaSE.Bh4VUuPZ_2oFpfU.webp&quot; alt=&quot;photo&quot; /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;占用内存&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;byte&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;byte b = 100;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-128 ~ 127&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short s = 1000;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;范围比 int 小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int age = 20;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最常用整数类型&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;long bigNum = 100000L;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;末尾加 &lt;code&gt;L&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;float pi = 3.14f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小数，末尾加 &lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double price = 19.99;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最常用小数类型&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char grade = &apos;A&apos;;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单个字符，用 &lt;code&gt;&apos; &apos;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 位&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean isOk = true;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只有 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;此处char与c++有所不同，c++为1个字节，并且java不区分32或64位操作系统&lt;/p&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变量的命名规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能用 &lt;strong&gt;字母、数字、下划线、美元符号&lt;/strong&gt;，且不能以数字开头&lt;/li&gt;
&lt;li&gt;不能用 Java 关键字（如 &lt;code&gt;class&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;见名知意（推荐小驼峰命名法：&lt;code&gt;myName&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;double a = 1.1;
double b = 1.1;
System.out.println(a*b);
//1.2100000000000002
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;此处和浮点数的存储有关系&lt;/p&gt;
&lt;p&gt;float		double&lt;/p&gt;
&lt;p&gt;精度：float 小数点后6位&lt;/p&gt;
&lt;p&gt;1.123456789&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;浮点型变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;double注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.double在任何系统下都占8个字节&lt;/p&gt;
&lt;p&gt;2.浮点数与整数在内存中的存储方式不同，不能单纯使用2n的形式来计算&lt;/p&gt;
&lt;p&gt;3.double的包装类型为Double&lt;/p&gt;
&lt;p&gt;4.double类型的内存布局遵守 IEEE 754 标准（和C语言一样），尝试使用有限的内存空间表示可能无限的小数，势必会存在一定的精度误差，英雌浮点数是个近似值，并不是精确值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;float注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.float类型在java中占4个字节，同样遵循 IEEE 754 标准，由于表示的数据精度范围小，一般在工程上用到浮点数都优先考虑double，不太推荐使用float，float的包装类型为Float。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符型变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.java中使用&lt;code&gt;单引号 + 单个字母 &lt;/code&gt;的形式表示字符字面值。&lt;/p&gt;
&lt;p&gt;2.计算机中的字符本质上是一个整数，在&amp;lt;span style=&quot;color:red&quot;&amp;gt;&lt;strong&gt;C语言中使用ASCll表示字符，而java中使用 Unicode 表示字符因此一个字符占用两个字节&lt;/strong&gt;&amp;lt;/span&amp;gt;，表示的字符种类更多，包括中文。所以Unicode的字符集比ASCll要大&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;布尔型变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.boolean 类型的变量只有两种取值，true表示真，false表示假&lt;/p&gt;
&lt;p&gt;2.java 的 boolean 类型和int 不能相互转换，&lt;strong&gt;不存在&lt;/strong&gt; 1表示true，0表示false 这样的用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在java中，当参与运算数据类型不一致时，就会进行类型转换，java中类型转换主要分为两种：自动类型转换(隐式) 和 强制类型转换(显式)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自动类型转换（隐式）：&lt;/p&gt;
&lt;p&gt;自动类型转换即：&lt;strong&gt;在代码编译时，编译器会自动进行处理&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;特点：&amp;lt;span style=&quot;color:red&quot;&amp;gt;&lt;strong&gt;数据范围小的转为数据范围大的时会自动进行&lt;/strong&gt;。&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转换只发生在赋值的过程里&lt;/strong&gt;，变量本身的类型不会改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;//整数类型的范围关系是：
byte &amp;lt; short &amp;lt; int &amp;lt; long &amp;lt; float &amp;lt; double

int a = 10;
long b = 10L;
b = a; 			//编译器会自动将int提升为long
b = (long) a;	//编译器自动帮你加上(long) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;强制类型转换（显式）：&lt;/p&gt;
&lt;p&gt;强制类型转换：代码需要经过一定的格式处理，不能自动完成。&lt;/p&gt;
&lt;p&gt;特点：数据范围大的到数据范围小的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = 3.14f;
double d = 3.14;
f =(float) d;	// float -&amp;gt; double,数据范围由大到小，需要强转，否则编译失败

//补充：
//当你参与运算的数据 小于4个字节的很好 会进行提升
byte a = 10;
byte b = 20;
//byte c = (byte)(a+b) //因为a + b会自动提升类型为int，底层为避免溢出而设计
int c = a+b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.不相干的类型，不能进行强制类型转换。&lt;/p&gt;
&lt;p&gt;2.将一个字面值常量进行赋值的时候，java 会自动针对数字范围进行检查。&lt;/p&gt;
&lt;p&gt;补充：题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;short a = 128;
byte b = (byte)a;
System.out.println(b); // -128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因：Java 的整数都是 &lt;strong&gt;二进制补码存储&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;short&lt;/strong&gt; 占 &lt;strong&gt;16 位&lt;/strong&gt;（2 字节），范围是 -32768 ~ 32767。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;byte&lt;/strong&gt; 占 &lt;strong&gt;8 位&lt;/strong&gt;（1 字节），范围是 -128 ~ 127。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重点：当你从大类型（&lt;code&gt;short&lt;/code&gt;）强制转换到小类型（&lt;code&gt;byte&lt;/code&gt;）时，只会保留低 8 位，高位直接丢弃。&lt;/p&gt;
&lt;p&gt;拆解过程：&lt;/p&gt;
&lt;p&gt;Step 1：128 的二进制（short，16 位）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000 0000 1000 0000   （十六进制：0x0080）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2：强制转换为 byte（取低 8 位）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1000 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 3：解释这个 8 位二进制（byte 类型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java 中，&lt;code&gt;byte&lt;/code&gt; 是有符号的，范围是 -128 ~ 127。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1000 0000&lt;/code&gt; 的最高位是 &lt;strong&gt;1&lt;/strong&gt;，说明它是一个负数（补码形式）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补码 → 原码的过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1000 0000 （补码）
= -128    （这是 byte 的最小值）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.java当中的字符串不是以\0结尾的&lt;/p&gt;
&lt;p&gt;2.当字符串和整数还在一起使用+号的意思 就是一个拼接的意思&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a = 10,b = 20;
System.out.println(&quot;a:&quot;+a + b);//a:1020
//原因：a:+a已经拼接表示为字符串了，因此该整体再与b之间也是拼接关系
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;部分情况下，需要将字符串和整型数字之间进行转换：&lt;/p&gt;
&lt;p&gt;1.int 转成 String&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int num = 10;
//mean1
String str1 = num + &quot;&quot;;
//mean2
String str2 = String.valueOf(num);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.String 转成 int&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str = &quot;100&quot;;
int num = Integer.parseInt(str);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>GitHub Pages配置</title><link>https://sirens007.github.io/posts/github-pages/</link><guid isPermaLink="true">https://sirens007.github.io/posts/github-pages/</guid><description>一篇关于建立GitHub Pages博客的文章.</description><pubDate>Wed, 27 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;环境依赖&lt;/h1&gt;
&lt;p&gt;在开始使用 Mizuki 之前，您需要确保系统满足以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Node.js &amp;gt;= 20&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pnpm &amp;gt;= 9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安装Node.js&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js 官网&lt;/a&gt; 下载并安装最新版本的 Node.js。建议使用 LTS 版本。&lt;/p&gt;
&lt;p&gt;安装完成后，打开终端或命令提示符，运行以下命令验证 Node.js 是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v
npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示版本号，则表示安装成功。&lt;/p&gt;
&lt;h2&gt;安装pnpm&lt;/h2&gt;
&lt;p&gt;如果您尚未安装 pnpm，可以通过 npm 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g pnpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后，打开终端或命令提示符，运行以下命令验证 pnpm 是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pnpm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示版本号，则表示安装成功。&lt;/p&gt;
&lt;h2&gt;安装Git&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;Git 官网&lt;/a&gt; 下载并安装适合您操作系统的 Git 版本。&lt;/p&gt;
&lt;p&gt;安装完成后，打开终端或命令提示符，运行以下命令验证 Git 是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示版本号，则表示安装成功。&lt;/p&gt;
&lt;h1&gt;项目启动&lt;/h1&gt;
&lt;h2&gt;1.克隆项目&lt;/h2&gt;
&lt;p&gt;首先将模板拉下到本地仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/matsuzaka-yuki/Mizuki.git
cd ...//cd到项目地址处
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2.安装依赖&lt;/h2&gt;
&lt;p&gt;使用 pnpm 安装项目依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pnpm install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3.配置博客&lt;/h2&gt;
&lt;p&gt;在启动项目之前，您需要根据自己的需求进行配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编辑 &lt;code&gt;src/config.ts&lt;/code&gt; 文件来自定义博客设置&lt;/li&gt;
&lt;li&gt;更新站点信息、主题颜色、横幅图片和社交链接&lt;/li&gt;
&lt;li&gt;配置翻译设置和特殊页面功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.启动开发服务器&lt;/h2&gt;
&lt;p&gt;运行以下命令启动开发服务器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pnpm dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动成功后，您可以在浏览器中访问 &lt;code&gt;http://localhost:4321&lt;/code&gt; 查看您的博客。&lt;/p&gt;
&lt;h2&gt;5.打包网站&lt;/h2&gt;
&lt;p&gt;在本地项目处运行以下命令将网站打包成静态文件，生成到 &lt;code&gt;dist&lt;/code&gt; 目录中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pnpm build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的 &lt;code&gt;dist&lt;/code&gt; 目录可以部署到您自己的服务器上。&lt;/p&gt;
&lt;h1&gt;部署到GitHub Pages&lt;/h1&gt;
&lt;p&gt;如果您希望将博客托管在 GitHub Pages 上，Mizuki 项目通常会包含一个 GitHub Actions 工作流，可以帮助您自动化部署过程。您需要确保在 &lt;code&gt;astro.config.mjs&lt;/code&gt; 中配置正确的 &lt;code&gt;base&lt;/code&gt; 路径。&lt;/p&gt;
&lt;p&gt;还有将&lt;code&gt;package.json&lt;/code&gt;的script中加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;vite build&quot;,  
    &quot;deploy&quot;: &quot;gh-pages -d dist -r https://github.com/&amp;lt;你的用户名&amp;gt;/&amp;lt;你的仓库名&amp;gt;.git&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总共要改的配置文件为&lt;code&gt;astro.config.mjs&lt;/code&gt;、&lt;code&gt;package.json&lt;/code&gt;、&lt;code&gt;src/config.ts&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;部署到 github.io 网址&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;astro.config.mjs&lt;/code&gt; 中配置文件设置 &lt;code&gt;site&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineConfig } from &apos;astro/config&apos;

export default defineConfig({
  site: &apos;https://sirens007.github.io/&apos;,
  base: &apos;/&apos;,
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Site&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;site&lt;/code&gt; 的值必须是以下之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于你的用户名的以下网址: &lt;code&gt;https://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为 GitHub 组织的私有页面 自动生成的随机网址：&lt;code&gt;https://&amp;lt;random-string&amp;gt;.pages.github.io/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果出现了以下情况，则不要设置 base 参数：&lt;/p&gt;
&lt;p&gt;你的页面是由根文件夹所提供。&lt;/p&gt;
&lt;p&gt;你的源码存储库是位于 https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Base&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;base&lt;/code&gt; 的值应该是你的仓库名称，以正斜杠开头，例如 &lt;code&gt;/my-blog&lt;/code&gt;。这样做是为了让 Astro 理解你的网站根目录是 &lt;code&gt;/my-repo&lt;/code&gt;，而不是默认的 &lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当配置了这个值后，你所有的内部页面链接都必须以你的 base 值作为前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;/my-repo/about&quot;&amp;gt;关于本站&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看更多关于配置 &lt;a href=&quot;https://docs.astro.build/zh-cn/reference/configuration-reference/#base&quot;&gt;base&lt;/a&gt; 值的信息。&lt;/p&gt;
&lt;h2&gt;（可选）在GitHub Pages上使用自定义域名&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;设置一个自定义域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以选择通过将一个 ./public/CNAME 文件添加到你的项目中，来设置自定义域&lt;/p&gt;
&lt;p&gt;这会将你的站点部署在你的自定义域而不是 &amp;lt;YOUR_USERNAME&amp;gt;.github.io。&lt;/p&gt;
&lt;p&gt;不要忘记为你的域名提供商配置 DNS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要配置 Astro 以在 GitHub Pages 上使用自定义域名，请将你的域名设置为 site 的值。不要为 &lt;code&gt;base&lt;/code&gt; 设置值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { defineConfig } from &apos;astro/config&apos;

export default defineConfig({
    site: &apos;https://example.com&apos;,
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;方法一：配置GitHub Action&lt;/h2&gt;
&lt;p&gt;在你的项目中的 &lt;code&gt;.github/workflows/&lt;/code&gt; 目录创建一个新文件 &lt;code&gt;deploy.yml&lt;/code&gt;，并粘贴以下 YAML 配置信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: Deploy to GitHub Pages

on:
# 每次推送到 `main` 分支时触发这个“工作流程”
# 如果你使用了别的分支名，请按需将 `main` 替换成你的分支名
push:
    branches: [ main ]
# 允许你在 GitHub 上的 Actions 标签中手动触发此“工作流程”
workflow_dispatch:

# 允许 job 克隆 repo 并创建一个 page deployment
permissions:
contents: read
pages: write
id-token: write

jobs:
build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout your repository using git
        uses: actions/checkout@v4
    - name: Install, build, and upload your site
        uses: withastro/action@v3
        # with:
        # path: . # 存储库中 Astro 项目的根位置。（可选）
        # node-version: 20 # 用于构建站点的特定 Node.js 版本，默认为 20。（可选）
        # package-manager: pnpm@latest # 应使用哪个 Node.js 包管理器来安装依赖项和构建站点。会根据存储库中的 lockfile 自动检测。（可选）

deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
    name: github-pages
    url: ${{ steps.deployment.outputs.page_url }}
    steps:
    - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（可选）如果你在本地开发期间或预览构建期间，将环境变量传入给 Astro 项目，则需要定义 deploy.yml 文件中的任何公共变量，以便在部署到 Github 页面时处理它们。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jobs:
build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout your repository using git
        uses: actions/checkout@v4
    - name: Install, build, and upload your site
        uses: withastro/action@v3
        env:
        # 使用单引号来包裹变量值
        PUBLIC_EVM_WALLET_ADDRESS: &apos;0x4bFc229A40d41698154336aFF864f61083E76659&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;在 GitHub 上，跳转到存储库的 Settings 选项卡并找到设置的 Pages 部分。&lt;/li&gt;
&lt;li&gt;选择 GitHub Actions 作为你网站的 Source，然后按 Save。&lt;/li&gt;
&lt;li&gt;选择 GitHub Actions 作为你网站的 Source，然后按 Save。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你的网站现在应该已完成发布了！当你将更改推送到 Astro 项目的存储库时，GitHub Action 将自动为你部署它们。&lt;/p&gt;
&lt;h2&gt;方法二：增加gh-pages分支&lt;/h2&gt;
&lt;h2&gt;安装部署&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pnpm add -D gh-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 &lt;code&gt;gh-pages&lt;/code&gt; 包，它会帮你把 &lt;code&gt;dist/&lt;/code&gt; 目录推送到 GitHub 仓库的 &lt;code&gt;gh-pages&lt;/code&gt; （自动创建）分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pnpm run build&lt;/code&gt; → 生成 &lt;code&gt;dist/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pnpm run deploy&lt;/code&gt; → 自动把 &lt;code&gt;dist/&lt;/code&gt; 上传到 GitHub Pages&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;日常维护&lt;/h1&gt;
&lt;h4&gt;1.修改/新增文章或页面&lt;/h4&gt;
&lt;p&gt;在本地项目里（比如 &lt;code&gt;src/content&lt;/code&gt;、&lt;code&gt;posts&lt;/code&gt;、&lt;code&gt;pages&lt;/code&gt; 等目录），新建或修改 Markdown/HTML/JSX 文件。&lt;/p&gt;
&lt;h4&gt;2. 重新构建&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;pnpm build
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：把修改后的源代码再打包到 &lt;code&gt;dist/&lt;/code&gt; 目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：GitHub Pages 只会展示 &lt;code&gt;dist&lt;/code&gt; 文件夹里的内容，而不会读取你的源代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 部署到 GitHub Pages&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;pnpm run deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：自动运行 &lt;code&gt;gh-pages -d dist&lt;/code&gt;，把最新的 &lt;code&gt;dist/&lt;/code&gt; 推送到 &lt;code&gt;gh-pages&lt;/code&gt; 分支。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：GitHub Pages 是根据 &lt;code&gt;gh-pages&lt;/code&gt; 分支的内容来渲染你的网站的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mizuki.mysqil.com/guide/deployment/#%E9%85%8D%E7%BD%AE-github-action&quot;&gt;部署 | Mizuki主题官方文档&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Git基础学习</title><link>https://sirens007.github.io/posts/git-experience/</link><guid isPermaLink="true">https://sirens007.github.io/posts/git-experience/</guid><description>一篇关于 Git 使用经验的文章.</description><pubDate>Wed, 27 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;📝以自己经验用Git&lt;/h2&gt;
&lt;h3&gt;1.Git基础概念&lt;/h3&gt;
&lt;p&gt;Git = word写文档	GitHub = 腾讯文档分享协作&lt;/p&gt;
&lt;p&gt;Git三个区域&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工作区（Working Directory）—— 你正在编辑的文件
  ↓ git add
暂存区（Staging Area）—— 即将提交的快照
  ↓ git commit
版本库（Repository）—— Git 保存的历史记录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完整的开发流程通常是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改代码
git add 文件名             # 添加文件到暂存区
git commit -m &quot;说明信息&quot;   # 提交暂存区到版本库
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;2.本地 Git 仓库操作&lt;/h3&gt;
&lt;p&gt;以下内容是指在终端中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;待填入名字&quot;
git config -- global user.email &quot;待填入邮箱&quot;	#建议使用注册GitHub的用户名和邮箱，便于同步
                                  # --global 表示在你这台电脑上的所有仓库都使用这套设置。

git init #建立Git仓库，初始化Git仓库
         #或者从GitHub上拉一个项目（如刚创建了远程仓库）
git clone https://github.com/Sirens007/MyStorage.git

#如创建一个新文件
echo &quot;#我的第一个项目&quot; &amp;gt; README.md
#添加到Git暂存区
git add README.md
#提交到本地仓库
git commit -m &quot;添加了README文件&quot;
#绑定 GitHub 仓库作为远程仓库 origin	（即origin为远程仓库昵称）
git remote add origin https://github.com/Sirens007/MyStorage.git
#首次推送GitHub
git push -u origin main #如果提示 main 不存在，可以先用 git branch -M main 把默认的 master 分支改名。

git status
#查看当前工作状态 （如查看还未暂存的文件
git log
#查看提交历史

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;3.查看状态与差异&lt;/h3&gt;
&lt;p&gt;当你已经完成了基本的 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 操作后，日常开发中你最常用的两个命令是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;：查看当前仓库状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt;：查看文件内容发生了哪些改动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一、git status —— 查看状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看当前工作区和暂存区的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git 会比较这三者的内容是否一致：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;工作目录中的文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暂存区中的文件（通过 git add 添加的）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后一次提交的版本（历史）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;details class=&quot;lake-collapse&quot;&amp;gt;
&amp;lt;summary id=&quot;u29606243&quot;&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;结果分析&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h4 id=&quot;98be1ecf&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot; style=&quot;color: #DF2A3F&quot;&amp;gt;🔴&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;ne-text&quot;&amp;gt;情况1：工作区干净&amp;lt;/span&amp;gt;&amp;lt;/h4&amp;gt;
&amp;lt;pre data-language=&quot;bash&quot; id=&quot;WQi54&quot; class=&quot;ne-codeblock language-bash&quot;&amp;gt;&amp;lt;code&amp;gt;$ git status
On branch master
nothing to commit, working tree clean&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&amp;lt;p id=&quot;u0e2b9816&quot; class=&quot;ne-p&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;意思是：没有文件被修改，也没有新增或删除。&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h4 id=&quot;3e1a3f71&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot; style=&quot;color: #DF2A3F&quot;&amp;gt;🟡&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;ne-text&quot;&amp;gt;情况2：修改了文件但还没 add&amp;lt;/span&amp;gt;&amp;lt;/h4&amp;gt;
&amp;lt;pre data-language=&quot;bash&quot; id=&quot;ZGtno&quot; class=&quot;ne-codeblock language-bash&quot;&amp;gt;&amp;lt;code&amp;gt;$ git status
modified:   hello.txt&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&amp;lt;p id=&quot;ufa272c14&quot; class=&quot;ne-p&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;说明 &amp;lt;/span&amp;gt;&amp;lt;code class=&quot;ne-code&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;hello.txt&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt; 有改动，但还没有被添加进暂存区。&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h4 id=&quot;c160fd94&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;🟢&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;ne-text&quot;&amp;gt;情况3：已 add 到暂存区但还没 commit&amp;lt;/span&amp;gt;&amp;lt;/h4&amp;gt;
&amp;lt;pre data-language=&quot;bash&quot; id=&quot;L2q4R&quot; class=&quot;ne-codeblock language-bash&quot;&amp;gt;&amp;lt;code&amp;gt;$ git status
Changes to be committed:
(use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
modified:   hello.txt&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、git diff —— 查看修改内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示当前工作目录中未加入暂存区的变更（对比的是：工作区 ↔ 暂存区）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;你也可以用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff hello.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来查看某个具体文件的改动。&lt;/p&gt;
&lt;p&gt;&amp;lt;details class=&quot;lake-collapse&quot;&amp;gt;&amp;lt;summary id=&quot;u423a2fc5&quot;&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;补充&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/summary&amp;gt;&amp;lt;h4 id=&quot;k8LQy&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;查看已经 add 但还未 commit 的差异：&amp;lt;/span&amp;gt;&amp;lt;/h4&amp;gt;&amp;lt;pre data-language=&quot;bash&quot; id=&quot;J3Z0b&quot; class=&quot;ne-codeblock language-git&quot;&amp;gt;&amp;lt;code&amp;gt;git diff --cached&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;p id=&quot;u52bf5124&quot; class=&quot;ne-p&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;或者：&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;pre data-language=&quot;bash&quot; id=&quot;cEllX&quot; class=&quot;ne-codeblock language-git&quot;&amp;gt;&amp;lt;code&amp;gt;git diff --staged&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;h4 id=&quot;u539c&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;作用：&amp;lt;/span&amp;gt;&amp;lt;/h4&amp;gt;&amp;lt;ul class=&quot;ne-ul&quot;&amp;gt;&amp;lt;li id=&quot;udf0dfced&quot; data-lake-index-type=&quot;0&quot;&amp;gt;&amp;lt;span class=&quot;ne-text&quot;&amp;gt;查看“暂存区”中与“上一次提交版本”之间的差异。&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h3&gt;4.文件恢复与版本回退&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;开发中你经常会遇到这些情况：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;想做的事&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;改错文件了&lt;/td&gt;
&lt;td&gt;想恢复回之前保存的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add 错文件了&lt;/td&gt;
&lt;td&gt;想撤回到未暂存状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;commit 之后后悔了&lt;/td&gt;
&lt;td&gt;想撤销或回退提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;改了很多但不想要了&lt;/td&gt;
&lt;td&gt;想恢复整个文件夹到之前状&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;本节主要命令：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git restore&lt;/code&gt;：恢复文件内容（推荐）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout&lt;/code&gt;：旧版本恢复（老派用法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset&lt;/code&gt;：取消暂存、版本回退&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt;：查看历史提交&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;一、恢复工作区文件：&lt;/strong&gt;&lt;code&gt;git restore&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git restore &amp;lt;filename&amp;gt;

eg:
echo &quot;bad line&quot; &amp;gt;&amp;gt; hello.txt      # 加了一行错误内容
git restore hello.txt             # 撤销这次改动
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;把某个文件恢复到上一次 &lt;code&gt;git add&lt;/code&gt; 或 &lt;code&gt;git commit&lt;/code&gt; 之后的状态，&lt;strong&gt;取消你刚刚改的内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背后原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Git 暂存区或仓库中拿出该文件的版本，覆盖当前工作区。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;二、撤销 &lt;strong&gt;&lt;code&gt;git add&lt;/code&gt;&lt;/strong&gt;：&lt;/strong&gt;&lt;code&gt;git restore --staged&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git restore --staged &amp;lt;filename&amp;gt;

eg:
git add hello.txt
git restore --staged hello.txt  #撤回add，但改动还在
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把文件从&lt;strong&gt;暂存区&lt;/strong&gt;移除，但保留工作区的改动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你 &lt;code&gt;git add&lt;/code&gt; 了一个不该提交的文件，可以用这条命令撤回。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;三、版本回退：&lt;/strong&gt;&lt;code&gt;git reset&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令：取消已经 add 的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset filename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等效于上面那句 &lt;code&gt;git restore --staged&lt;/code&gt;，只是老一点的写法。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;命令：回退到上一个提交版本（慎用）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset --hard HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把整个项目（工作区 + 暂存区）恢复到上一次提交的状态。&lt;/p&gt;
&lt;p&gt;❗❗ 注意：&lt;code&gt;--hard&lt;/code&gt; 是“硬回退”，&lt;strong&gt;不可恢复的清空当前修改&lt;/strong&gt;，一定要确认再用！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;四、查看历史版本：&lt;/strong&gt;&lt;code&gt;git log&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示提交历史&lt;/li&gt;
&lt;li&gt;会看到一堆 &lt;code&gt;commit xxx...&lt;/code&gt; 的 ID、作者、时间、提交说明&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git log

eg:
git log -p hello.txt	#查看历史内容改了什么
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.分支管理（分支的创建、切换、合并）&lt;/h3&gt;
&lt;p&gt;在实际开发中，我们经常会遇到这种需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不打扰主线代码，先试试一个新功能&lt;/li&gt;
&lt;li&gt;多个开发人员各自写各自的功能&lt;/li&gt;
&lt;li&gt;想在多个版本之间切换工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时，就要用到「&lt;strong&gt;分支（branch）&lt;/strong&gt;」来隔离、管理不同的开发线。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:#DF2A3F;&quot;&amp;gt;补充对分支的理解，如我在main分支创建了a.txt （未add），此时创建dev分支可以看见main分支对a.txt的更改。但如果我在dev上commit之后，回到main之后则不存在a.txt文件了，就相当于两个工作区一样&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Git 分支基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主分支&lt;/strong&gt;：默认叫 &lt;code&gt;master&lt;/code&gt;（或 &lt;code&gt;main&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分支的本质&lt;/strong&gt;：一个指向某次提交的“指针”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt;：指向当前分支的位置（你正在干活的分支）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**1.查看已有分支： **&lt;code&gt;git branch 分支名&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;会列出当前所有分支，当前所在的分之前有&lt;code&gt;*&lt;/code&gt;标记&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;2.创建新分支：&lt;/strong&gt;&lt;code&gt;git branch 分支名&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建一个名为dev的新分支，复制自当前分支的最新提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;3.切换分支：&lt;/strong&gt;&lt;code&gt;git switch 分支名&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git switch dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;此时已切换dev分支，开始在上面开发了&lt;/li&gt;
&lt;li&gt;如果是老版本Git，也可以用&lt;code&gt;git checkout dev&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;4.创建并切换新分支：一条命令搞定&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git switch -c dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch dev
git switch dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 会尝试把&lt;code&gt;dev&lt;/code&gt;上的改动合并进master，如果没有冲突，会自动完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;5.合并分支：&lt;code&gt;git merge&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切换会主分支后，合并新分支的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git switch main
git merge dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 会尝试把&lt;code&gt;dev&lt;/code&gt;上的改动合并进main，如果没有冲突，会自动完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;6.删除分支（合并后清理）：&lt;code&gt;git branch -d&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -d dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你确认合并完了，就可以删掉旧分支。&lt;/p&gt;
&lt;h3&gt;6.搭建ssh远程连接（无需梯子）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一、配置git bash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在git bash中运行以下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t ed25519 -C &quot;你的GitHub邮箱&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enter file in which to save the key (~/.ssh/id_ed25519):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以直接回车（会覆盖旧的 id_ed25519）&lt;br /&gt;
或者输入一个新名字，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~/.ssh/id_ed25519_laptop
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;二、启用新的ssh key&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eval &quot;$(ssh-agent -s)&quot;

ssh-add ~/.ssh/id_ed25519_laptop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三、把公钥加到Github&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat ~/.ssh/id_ed25519_laptop.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制整段（从 &lt;code&gt;ssh-ed25519&lt;/code&gt; 开始到最后），&lt;br /&gt;
然后在 GitHub → &lt;strong&gt;Settings&lt;/strong&gt; → &lt;strong&gt;SSH and GPG keys&lt;/strong&gt; → &lt;strong&gt;New SSH key&lt;/strong&gt; → 粘贴保存。&lt;br /&gt;
标题建议写成 “Laptop - 2025” 这种好区分的名字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、验证&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hi Sirens007! You&apos;ve successfully authenticated...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明配置成功&lt;/p&gt;
&lt;h3&gt;7.远程仓库操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.远程仓库概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地 Git 仓库 = 你电脑上的版本库（&lt;code&gt;.git&lt;/code&gt; 目录）。&lt;br /&gt;
远程仓库 = 存在于服务器（比如 GitHub）上的版本库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.四个常用操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）clone - 从远程仓库下载到本地&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/Sirens007/MyStorage.git

#运行后，你本地就有一个 myproject 目录，并且可以直接 git pull 或 git push。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会在本地新建一个文件夹&lt;/li&gt;
&lt;li&gt;自动把该仓库的所有版本历史下载到本地&lt;/li&gt;
&lt;li&gt;自动设置好 &lt;code&gt;origin&lt;/code&gt; 这个远程名，指向该仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（2）remote - 管理远程仓库地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看已有远程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加远程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/Sirens007/MyStorage.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改远程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote set-url origin &amp;lt;新地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除远程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote remove origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;origin&lt;/code&gt; 是默认的远程仓库名字，你也可以用别的名字。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（3）push - 推送本地代码到远程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一次推送（如果远程没有内容）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push -u origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;origin&lt;/code&gt;：远程仓库名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;：分支名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt;：记住这个推送目标，下次可以直接&lt;code&gt;git push&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后推送就可以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（4）pull - 从远程拉取最新版本&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把远程 main 分支的最新提交下载到本地&lt;/li&gt;
&lt;li&gt;并与本地当前分支合并&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果远程没有变化，你会看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Already up to date.
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（5）远程分支与本地分支的关系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你执行 &lt;code&gt;git clone&lt;/code&gt; 或 &lt;code&gt;git fetch&lt;/code&gt; 后，Git 会在本地维护远程分支的快照，叫做 &lt;strong&gt;远程跟踪分支&lt;/strong&gt;，格式一般是 &lt;code&gt;origin/分支名&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;本地分支和远程分支是分开的，推送（&lt;code&gt;push&lt;/code&gt;）和拉取（&lt;code&gt;pull&lt;/code&gt;）就是它们之间的同步操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（6）查看远程分支&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -r
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只列出远程仓库的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git branch -a
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;本地和远程所有分支都会显示&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（7）跟踪远程分支的新建本地分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果远程有个分支，你想在本地工作，需要先新建一个本地分支跟踪远程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git switch-c dev origin/dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这会基于远程&lt;code&gt;dev&lt;/code&gt;分支新建本地&lt;code&gt;dev&lt;/code&gt;分支&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（8）远程仓库冲突解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多人合作时，推送可能被拒绝，提示远程有更新需要先拉取：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push
To https://github.com/xxx.git
 ! [rejected]        main -&amp;gt; main (fetch first)
error: failed to push some refs to &apos;https://github.com/xxx.git&apos;
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时，需要先拉取远程的最新修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--rebase&lt;/code&gt; 表示把你的提交“挪到”最新远程修改之后，避免额外合并提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;（9）查看远程仓库详情&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程分支状态&lt;/li&gt;
&lt;li&gt;你本地分支对应的上游分支&lt;/li&gt;
&lt;li&gt;是否有可推送或拉取的内容&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Git基础命令</title><link>https://sirens007.github.io/posts/git-basic-commands/</link><guid isPermaLink="true">https://sirens007.github.io/posts/git-basic-commands/</guid><description>一篇关于 Git基础命令的笔记.</description><pubDate>Wed, 20 Aug 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;📝Git工作流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/photo1.DpPVMtWx_19wPQ8.webp&quot; alt=&quot;photo1&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;1.克隆仓库&lt;/h3&gt;
&lt;p&gt;如果你要参与一个已有的项目，通常会创建一个新的分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/username/repo.git
cd repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2.创建新分支&lt;/h3&gt;
&lt;p&gt;为了避免直接在main或master分支上进行开发，通常会创建一个新的分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.工作目录&lt;/h3&gt;
&lt;p&gt;在工作目录中进行代码编辑、添加新文件或删除不需要的文件。&lt;/p&gt;
&lt;h3&gt;4.暂存文件&lt;/h3&gt;
&lt;p&gt;将修改的文件添加到暂存区，以便进行下一步的提交操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add filename
# 或者添加所有修改的文件
git add .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5.提交更改&lt;/h3&gt;
&lt;p&gt;将暂存区的更改提交到本地仓库，并添加提交信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &quot;Add new feature&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;6.拉取最新更改&lt;/h3&gt;
&lt;p&gt;推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin main
# 或者如果在新的分支上工作
git pull origin new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;7.推送更改&lt;/h3&gt;
&lt;p&gt;将本地的提交推送到远程仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;8.创建Pull Request（PR）&lt;/h3&gt;
&lt;p&gt;在github或其他托管平台上创建Pull Request，邀请团队成员进行代码审查。PR合并后，你的更改就会合并到主分支。&lt;/p&gt;
&lt;h3&gt;9.合并更改&lt;/h3&gt;
&lt;p&gt;在PR审核通过并合并后，可以将远程仓库的主分支合并到本地分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout main
git pull origin main
git merge new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;10.删除分支&lt;/h3&gt;
&lt;p&gt;如果不需要新功能分支，可以将其删除：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -d new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者从远程仓库删除分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin --delete new-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;📝Git创建仓库&lt;/h2&gt;
&lt;h3&gt;git init&lt;/h3&gt;
&lt;p&gt;Git使用git init命令来初始化一个Git仓库，Git的很多命令都需要在Git的仓库中运行，所以git init是使用Git的第一个命令。&lt;/p&gt;
&lt;p&gt;在执行完git init命令后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入想要创建仓库的目录，或者先创建一个新的目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir my-project
cd my-project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用当前目录作为Git仓库，我们只需使用它初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该命令执行完成后会在当前目录生成一个.git目录。&lt;/p&gt;
&lt;p&gt;使用我们指定目录作为Git仓库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init newrepo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初始化后，会在newrepo目录下会出现一个名为.git的目录，所有Git需要的数据和资源都存放在这个目录中。&lt;/p&gt;
&lt;p&gt;如果当前目录下有几个文件想要纳入版本控制，需要先使用git add 命令告诉Git开始对这些文件进行跟踪，然后提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add *.c 	 #将所有.c文件纳入版本控制
git add README #添加README文件（一般为项目说明文档），可以是README.md、README.txt
git commit -m &apos;初始化项目版本&apos;  #
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令将目录一下以 .c 结尾及README文件提交到仓库中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 在Linux系统中，commit信息使用单引号 &apos; ，Windows系统，commit信息使用双引号&quot;。&lt;/p&gt;
&lt;p&gt;所以在git bash中 git commit -m &apos;提交说明&apos; 这样是可以的，在Windows命令行中就要使用双引号 git commit -m &quot;提交说明&quot;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;git clone&lt;/h3&gt;
&lt;p&gt;我们使用git clone 从现有的Git仓库中拷贝项目（类似svn checkout）。&lt;/p&gt;
&lt;p&gt;克隆仓库的命名格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone &amp;lt;repo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要克隆到指定的目录，可以使用以下命令格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone &amp;lt;repo&amp;gt; &amp;lt;directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;repo:Git仓库&lt;/li&gt;
&lt;li&gt;directory:本地仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，要克隆Ruby语言的Git代码仓库Grit，可以用下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://github.com/Sirens007/MyStorage.git Mystorage
#git:为Git专属协议，类似https

#git clone git://github.com/Sirens007/MyStorage.git 是仓库地址，指向Github上名为MyStorage的仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;git的设置使用 git config 命令&lt;/p&gt;
&lt;p&gt;显示当前的git配置信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --list
#输出以下信息
credential.helper=osxkeychain
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true
core.ignorecase=true
core.precomposeunicode=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑git配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config -e	#针对当前仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config -e --global	#针对系统上所有仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置提交代码时的用户信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;Sirens007&quot;
git config --global user.email &quot;2921646312@qq.com&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果去掉 --global参数支队当前仓库有效。&lt;/p&gt;
&lt;h2&gt;Git基本操作&lt;/h2&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);&quot;&amp;gt;Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);&quot;&amp;gt;本章将对有关创建与提交你的项目快照的命令作介绍。&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;font style=&quot;color:rgb(51, 51, 51);&quot;&amp;gt;Git常用的是以下6个命令：git clone、git push、git add、git commit、git checkout、git pull，之后会详细介绍&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sirens007.github.io/_astro/photo2.Mm2ndKAO_Z2pGPqB.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;workplace：工作区&lt;/li&gt;
&lt;li&gt;staging area：暂存区/缓存区&lt;/li&gt;
&lt;li&gt;local repository：版本库或本地仓库&lt;/li&gt;
&lt;li&gt;remote  respository：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个简单的操作步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
git add
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;git init - 初始化仓库。&lt;/li&gt;
&lt;li&gt;git add - 添加文件到暂存区。&lt;/li&gt;
&lt;li&gt;git commit - 将暂存区内容添加到仓库中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建仓库命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;git创建仓库的命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git init&lt;/td&gt;
&lt;td&gt;初始化仓库&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git clone&lt;/td&gt;
&lt;td&gt;拷贝一份远程仓库，也就是下载一个项目&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;提交与修改&lt;/h3&gt;
&lt;p&gt;Git的工作就是创建和保存你的项目的快照及与之后的快照进行对比。&lt;/p&gt;
&lt;p&gt;下表列出有关创建与提交你的项目的快照的命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git add&lt;/td&gt;
&lt;td&gt;添加文件到暂存区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git status&lt;/td&gt;
&lt;td&gt;查看仓库当前的状态，显示有变更的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git diff&lt;/td&gt;
&lt;td&gt;比较文件的不同，即暂存区和工作区的差异&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git difftool&lt;/td&gt;
&lt;td&gt;使用外部差异工具查看和比较文件的更改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git range-diff&lt;/td&gt;
&lt;td&gt;比较两个提交范围之间的差异&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git commit&lt;/td&gt;
&lt;td&gt;提交暂存区到本地仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git reset&lt;/td&gt;
&lt;td&gt;回退版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git rm&lt;/td&gt;
&lt;td&gt;将文件从暂存区和工作区中删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git mv&lt;/td&gt;
&lt;td&gt;移动或重命名工作区文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git notes&lt;/td&gt;
&lt;td&gt;添加注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git checkout&lt;/td&gt;
&lt;td&gt;分支切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git switch（Git 2.23版本）&lt;/td&gt;
&lt;td&gt;更清晰地切换分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git restore（Git 2.23版本）&lt;/td&gt;
&lt;td&gt;恢复或撤销文件的更改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git show&lt;/td&gt;
&lt;td&gt;显示Git对象的详细信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;提交日志&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git log&lt;/td&gt;
&lt;td&gt;查看历史提交记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git blame &amp;lt;file&amp;gt;&lt;/td&gt;
&lt;td&gt;以列表形式查看指定文件的历史修改记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git shortlog&lt;/td&gt;
&lt;td&gt;生成简洁的提交日志摘要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git describe&lt;/td&gt;
&lt;td&gt;生成一个可读的字符串，该字符串基于Git的标签系统来描述当前的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;远程操作&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git remote&lt;/td&gt;
&lt;td&gt;远程仓库操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git fetch&lt;/td&gt;
&lt;td&gt;从远程获取代码库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git pull&lt;/td&gt;
&lt;td&gt;下载远程代码并合并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git push&lt;/td&gt;
&lt;td&gt;上传远程代码并合并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git submodule&lt;/td&gt;
&lt;td&gt;管理包含其他Git仓库的项目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Git文件状态&lt;/h3&gt;
&lt;p&gt;Git的文件状态分为三种：工作目录（Working Directory）、暂存区（Staging Area）、本地仓库（Local Repository）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作目录（Working Directory）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作目录是你在本地计算机上看到的项目文件。它是你实际操作文件的地方，包括查看、编辑、删除和创建文件。所有对文件的更改首先发生在工作目录中。&lt;/p&gt;
&lt;p&gt;在工作目录中的文件可能有以下几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未跟踪（Untracked）：新创建的文件，未被Git记录。&lt;/li&gt;
&lt;li&gt;已修改（Modified）：已被Git跟踪的文件发生了更改，但这些更改还没有被提交到Git记录中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;暂存区（Staging Area）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;暂存区，也被称为索引（Index），是一个临时存储区域，用于保存即将提交到本地仓库的更改。你可以选择性地将工作目录中的更改添加到暂存区中，这样你就可以一次提交多个文件的更改，而不必提交所有文件的更改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用git add &amp;lt;filename&amp;lt;filename&amp;gt;&amp;gt; 命令将文件从工作目录添加到暂存区。&lt;/li&gt;
&lt;li&gt;使用git add . 命令将当前目录下的所有更改添加到暂存区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本地仓库（Local Respository）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地仓库是一个隐藏在 .git 目录中的数据库，用于存储项目的所有提交历史记录。每次你提交更改时，Git会将暂存区中的内容保存到本地仓库中。&lt;/p&gt;
&lt;p&gt;使用 git commit -m &quot;commit message&quot; 命令将暂存区中的更改提交到本地仓库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件状态的转换流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未跟踪（Untracked）：&lt;/strong&gt; 新创建的文件最初是未跟踪的。它们存在于工作目录中，但没有被Git跟踪。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git add  newfile.txt  	# 添加文件到暂存区&lt;/p&gt;
&lt;p&gt;git status           	       # 查看状态，显示 newfile.txt 在暂存区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;已跟踪（Tracked）：&lt;/strong&gt;      通过git add 命令将未跟踪的文件添加到暂存区后，文件变为已跟踪状态。&lt;/p&gt;
</content:encoded></item></channel></rss>